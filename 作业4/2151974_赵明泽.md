2151974 赵明泽

### 第四次作业

#### 目录

[TOC]

#### 第一题：宏汇编的使用

##### 要求

用macro实现替换过程调用

##### 实现

首先，写一段简单的加法程序，初步感受宏汇编，如下：

```assembly
summ macro x1, x2, result	;宏定义，有3个哑元
mov ax, x1
add ax, x2
mov result, ax
endm

xor ax, ax		;清空寄存器
xor bx, bx
xor cx, cx
xor dx, dx
mov bx, 123		;初始化参数
mov cx, 456

SUMM bx, cx, dx		;宏调用
;call show
mov  ah, 4ch
int  21h
```

输出结果如下：

```asciiarmor
579
```

使用`DEBUG`工具查看宏在程序运行过程中的表现，发现一开始并没有执行宏这段程序，后面执行时，也没有地址的跳转，而是直接把宏的代码拿过来执行，如图：

![u1](.\u1.png)

查阅资料，发现这种方式叫[宏展开](https://blog.csdn.net/weixin_45605341/article/details/106130656)。

然后，尝试改写上一次作业，王爽教材实验7，部分代码对比如下：

修改前：

```assembly
space:                                  ;存储空格
        mov  dl, " "                    ;存入空格
        mov  byte ptr es:[di], dl       ;写入一个字节
        ret                             ;结束
```

调用：

```assembly
call space
```

修改后：

```assembly
space   macro x
        mov  x, " "                    ;存入空格
        mov  byte ptr es:[di], x       ;写入一个字节
        endm
```

调用：

```assembly
space dl
```

宏与子程序都是编写结构化程序的重要手段,两者各有特色。相同之处，宏和子程序都可以定义为一段功能程序，可以被其他程序调用。不同之处如下：

* 宏指令利用哑元和实元进行参数传递。宏调用时用实元取代哑元，避免了子程序因参数传递带来的麻烦。
* 变元可以是指令的操作码或操作码的一部分，在汇编的过程中指令可以改变。
* 宏调用时没有保护断点和现场的概念，因为在汇编时已经用宏展开把这段程序插人主程序中了。而子程序每执行一次CALL指令，就要对断点和现场进行保护，把断点处的地址指针和相关寄存器人栈保存，从子程序中返回时要恢复现场和弹出断点地址。
* 宏的缺点是随着宏调用次数的增加，主程序代码会不断加长。

通常当程序较短、传递参数较多或要快速执行时，采用宏比较合适；当程序较长或对内存空间有要求时，选用子程序比较好。
